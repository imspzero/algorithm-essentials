"use strict";(self.webpackChunkalgorithm_essentials=self.webpackChunkalgorithm_essentials||[]).push([[9369],{3905:(e,t,n)=>{n.d(t,{Zo:()=>m,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},m=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(n),d=a,h=c["".concat(u,".").concat(d)]||c[d]||p[d]||i;return n?r.createElement(h,l(l({ref:t},m),{},{components:n})):r.createElement(h,l({ref:t},m))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var u in t)hasOwnProperty.call(t,u)&&(o[u]=t[u]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var s=2;s<i;s++)l[s]=n[s];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},5162:(e,t,n)=>{n.d(t,{Z:()=>l});var r=n(7294),a=n(6010);const i="tabItem_Ymn6";function l(e){let{children:t,hidden:n,className:l}=e;return r.createElement("div",{role:"tabpanel",className:(0,a.Z)(i,l),hidden:n},t)}},5488:(e,t,n)=>{n.d(t,{Z:()=>d});var r=n(7462),a=n(7294),i=n(6010),l=n(2389),o=n(7392),u=n(7094),s=n(2466);const m="tabList__CuJ",p="tabItem_LNqP";function c(e){var t,n;const{lazy:l,block:c,defaultValue:d,values:h,groupId:f,className:b}=e,v=a.Children.map(e.children,(e=>{if((0,a.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=h?h:v.map((e=>{let{props:{value:t,label:n,attributes:r}}=e;return{value:t,label:n,attributes:r}})),y=(0,o.l)(g,((e,t)=>e.value===t.value));if(y.length>0)throw new Error('Docusaurus error: Duplicate values "'+y.map((e=>e.value)).join(", ")+'" found in <Tabs>. Every value needs to be unique.');const k=null===d?d:null!=(t=null!=d?d:null==(n=v.find((e=>e.props.default)))?void 0:n.props.value)?t:v[0].props.value;if(null!==k&&!g.some((e=>e.value===k)))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+k+'" but none of its children has the corresponding value. Available values are: '+g.map((e=>e.value)).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");const{tabGroupChoices:w,setTabGroupChoices:x}=(0,u.U)(),[N,O]=(0,a.useState)(k),T=[],{blockElementScrollPositionUntilNextRender:P}=(0,s.o5)();if(null!=f){const e=w[f];null!=e&&e!==N&&g.some((t=>t.value===e))&&O(e)}const j=e=>{const t=e.currentTarget,n=T.indexOf(t),r=g[n].value;r!==N&&(P(t),O(r),null!=f&&x(f,String(r)))},E=e=>{var t;let n=null;switch(e.key){case"ArrowRight":{var r;const t=T.indexOf(e.currentTarget)+1;n=null!=(r=T[t])?r:T[0];break}case"ArrowLeft":{var a;const t=T.indexOf(e.currentTarget)-1;n=null!=(a=T[t])?a:T[T.length-1];break}}null==(t=n)||t.focus()};return a.createElement("div",{className:(0,i.Z)("tabs-container",m)},a.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":c},b)},g.map((e=>{let{value:t,label:n,attributes:l}=e;return a.createElement("li",(0,r.Z)({role:"tab",tabIndex:N===t?0:-1,"aria-selected":N===t,key:t,ref:e=>T.push(e),onKeyDown:E,onFocus:j,onClick:j},l,{className:(0,i.Z)("tabs__item",p,null==l?void 0:l.className,{"tabs__item--active":N===t})}),null!=n?n:t)}))),l?(0,a.cloneElement)(v.filter((e=>e.props.value===N))[0],{className:"margin-top--md"}):a.createElement("div",{className:"margin-top--md"},v.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==N})))))}function d(e){const t=(0,l.Z)();return a.createElement(c,(0,r.Z)({key:String(t)},e))}},5710:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>u,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var r=n(7462),a=(n(7294),n(3905)),i=n(5488),l=n(5162);const o={title:"Next Permutation"},u=void 0,s={unversionedId:"array/next-permutation",id:"array/next-permutation",title:"Next Permutation",description:"\u63cf\u8ff0",source:"@site/docs/array/next-permutation.md",sourceDirName:"array",slug:"/array/next-permutation",permalink:"/array/next-permutation",draft:!1,editUrl:"https://github.com/soulmachine/algorithm-essentials/edit/master/docs/array/next-permutation.md",tags:[],version:"current",frontMatter:{title:"Next Permutation"},sidebar:"someSidebar",previous:{title:"4Sum II",permalink:"/array/4sum-ii"},next:{title:"Permutation Sequence",permalink:"/array/permutation-sequence"}},m={},p=[{value:"\u63cf\u8ff0",id:"\u63cf\u8ff0",level:3},{value:"\u5206\u6790",id:"\u5206\u6790",level:3},{value:"\u4ee3\u7801",id:"\u4ee3\u7801",level:3},{value:"\u76f8\u5173\u9898\u76ee",id:"\u76f8\u5173\u9898\u76ee",level:3}],c={toc:p};function d(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h3",{id:"\u63cf\u8ff0"},"\u63cf\u8ff0"),(0,a.kt)("p",null,"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers."),(0,a.kt)("p",null,"If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order)."),(0,a.kt)("p",null,"The replacement must be in-place, do not allocate extra memory."),(0,a.kt)("p",null,"Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"1,2,3 \u2192 1,3,2\n3,2,1 \u2192 1,2,3\n1,1,5 \u2192 1,5,1\n")),(0,a.kt)("h3",{id:"\u5206\u6790"},"\u5206\u6790"),(0,a.kt)("p",null,"\u7b97\u6cd5\u8fc7\u7a0b\u5982\u4e0b\u56fe\u6240\u793a\uff08\u6765\u81ea",(0,a.kt)("a",{parentName:"p",href:"http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html"},"http://fisherlei.blogspot.com/2012/12/leetcode-next-permutation.html"),"\uff09\u3002"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"\u4e0b\u4e00\u4e2a\u6392\u5217\u7b97\u6cd5\u6d41\u7a0b",src:n(7610).Z,width:"951",height:"730"})),(0,a.kt)("h3",{id:"\u4ee3\u7801"},"\u4ee3\u7801"),(0,a.kt)(i.Z,{defaultValue:"java",values:[{label:"Java",value:"java"},{label:"C++",value:"cpp"}],mdxType:"Tabs"},(0,a.kt)(l.Z,{value:"java",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"// Next Permutation\n// Time Complexity: O(n), Space Complexity: O(1)\npublic class Solution {\n    public void nextPermutation(int[] nums) {\n        nextPermutation(nums, 0, nums.length);\n    }\n    private static boolean nextPermutation(int[] nums, int begin, int end) {\n        // From right to left, find the first digit(partitionNumber)\n        // which violates the increase trend\n        int p = end - 2;\n        while (p > -1 && nums[p] >= nums[p + 1]) --p;\n\n        // If not found, which means current sequence is already the largest\n        // permutation, then rearrange to the first permutation and return false\n        if(p == -1) {\n            reverse(nums, begin, end);\n            return false;\n        }\n\n        // From right to left, find the first digit which is greater\n        // than the partition number, call it changeNumber\n        int c = end - 1;\n        while (c > 0 && nums[c] <= nums[p]) --c;\n\n        // Swap the partitionNumber and changeNumber\n        swap(nums, p, c);\n        // Reverse all the digits on the right of partitionNumber\n        reverse(nums, p+1, end);\n        return true;\n    }\n    private static void swap(int[] nums, int i, int j) {\n        int tmp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = tmp;\n    }\n    private static void reverse(int[] nums, int begin, int end) {\n        end--;\n        while (begin < end) {\n            swap(nums, begin++, end--);\n        }\n    }\n};\n"))),(0,a.kt)(l.Z,{value:"cpp",mdxType:"TabItem"},(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-cpp"},"// Next Permutation\n// Time Complexity: O(n), Space Complexity: O(1)\nclass Solution {\npublic:\n    void nextPermutation(vector<int> &nums) {\n        next_permutation(nums, 0, nums.size());\n    }\nprivate:\n    bool next_permutation(vector<int> &nums, int begin, int end) {\n        // From right to left, find the first digit(partitionNumber)\n        // which violates the increase trend\n        int p = end - 2;\n        while (p > -1 && nums[p] >= nums[p + 1]) --p;\n\n        // If not found, which means current sequence is already the largest\n        // permutation, then rearrange to the first permutation and return false\n        if(p == -1) {\n            reverse(&nums[begin], &nums[end]);\n            return false;\n        }\n\n        // From right to left, find the first digit which is greater\n        // than the partition number, call it changeNumber\n        int c = end - 1;\n        while (c > 0 && nums[c] <= nums[p]) --c;\n\n        // Swap the partitionNumber and changeNumber\n        swap(nums[p], nums[c]);\n        // Reverse all the digits on the right of partitionNumber\n        reverse(&nums[p+1], &nums[end]);\n        return true;\n    }\n};\n")))),(0,a.kt)("h3",{id:"\u76f8\u5173\u9898\u76ee"},"\u76f8\u5173\u9898\u76ee"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/array/permutation-sequence"},"Permutation Sequence")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/brute-force/permutations"},"Permutations")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/brute-force/permutations-ii"},"Permutations II")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/brute-force/combinations"},"Combinations"))))}d.isMDXComponent=!0},7610:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/next-permutation-24f8a843d6d28d13b07893f1791ca165.png"}}]);